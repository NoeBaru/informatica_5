CREATE DDL(dATA Definition Language)
INSERT INTO, UPDATE e DELETE DML
Query con select


join: per mettere insieme due colonne (una di fianco all'altra)
unione: per mettere insieme due tabelle (una dopo l'altra)

condizione di congiunzione: campi che uniscono le tabelle, necessari perché sennò fa il prodotto cartesiano

tupla: la riga di qualunque tabella
grado: numero di colonne
cardinalità: numero di righe
istanza: insieme di tutte le righe e colonne (la tabella)

self join: join della stessa tabella con due alias diversi

distinct: se ci possono essere due righe identiche lo metto, così non le ripete

X: peratore insiemistico tra tabelle (prodotto cartesiano)
union: due tabelle con le stesse colonne vengono messe una sotto l'altra
-: quando c'è può essere NULL quindi non metto "NOT NULL"

la tabella risultato del prodotto cartesiano avrà un grado uguale alla somma dei gradi delle tabelle di partenza (es.2x1 = 3)
la cardinalità è il prodotto delle cardinalità delle tabelle iniziali

chiave primaria: sottolineato
chiave esterna: tratteggio sotto o con asterisco

chiave esterna comando:
- ON UPDATE CASCADE ON DELETE SET NULL se il campo può essere nullo
- ON UPDATE CASCADE ON DELETE RESTRICT 

COMANDI:

//crea la tabella
CREATE TABLE sedeA (
    codOperaio CHAR(4),
    sesso CHAR(1) NOT NULL CHECK (sesso IN ('M', 'F', 'm', 'f')),
    assuntoIl DATE NOT NULL,
    stipendio DECIMAL(10,2) NOT NULL CHECK (stipendio >= 0),
    codR INTEGER NOT NULL,
    PRIMARY KEY (codOperaio),
    FOREIGN KEY (codR) REFERENCES responsabili(codResp)
        ON DELETE RESTRICT ON UPDATE CASCADE
);

//popola la tabella
INSERT INTO sedeB
VALUES
('BCVL', 'M', '2010-04-03', 972.58, 3);

//cancella una riga (o senza where tutta la tabella)
DELETE FROM sedeB
where
('BCVL', 'M', '2010-04-03', 972.58, 3);

//taglio orizzontale con where
SELECT *
FROM SedeA
WHERE sesso = 'M'

//taglio verticale
SELECT codOperaio, stipendio
FROM SedeA
WHERE sesso = 'M'

//aggiungo la seguente riga per ordinare in ordine crescente ASC sottinteso o aggiungo DESC per decrescente
ORDER BY stipendio

//evita di ripetere gli stessi dati
SELECT DISTINCT stipendio
FROM SedeA
WHERE sesso = 'M'
ORDER BY stipendio DESC

//per averli in ordine del codice del responsabile
SELECT *
FROM SedeA
WHERE sesso = 'M'
ORDER BY codeR, codOperaio

//prodotto cartesiano: insieme di tutte le possibili combinazioni di righe delle due o più tabelle inserite
SELECT *
FROM sedeB, Responsabili;

//congiunzione o equi join naturale (equi: c'è l'=. naturale: non ripeto le colonne che si ripetono)
SELECT sedeB.*, cognome, nome --così prendo tutto di sedeB e solo le ultime due colonne di Responsabili senza ripetere così il codiceR
FROM sedeB, Responsabili;
WHERE codR = codResp --WHERE sedeB.codR = responsabili.codResp nel caso io abbia lo stesso nome uso la dot notation

//posso mettere degli alias nella select e rinominare le intestazioni di colonna e delle tabelle
SELECT b.*, cognome AS "cognome responsabile", nome AS "nome responsabile"
FROM SedeB b, responsabili r
WHERE b.codR = r.codResp

//per trovare uan data specifica

AND strftime('%Y', assuntoIl) = "2011"

oppure fatto in SQL standard è: AND YEAR(assuntoIl) = 2011

//controllo che il voto sia in un range da a 
CHECK (voto BETWEEN 0 AND 10)

//controllo che l'anno di nascita non sia nel futuro
YEAR(annoNascita) = YEAR(CURRENT_DATE)

//usando una stringa la cerca identica
SELECT game.*, genre.genre_name
FROM game, genre
WHERE genre.genre_name = "Fighting" AND genre.id = game.genre_id

//usando LIKE cerco la stringa simile
SELECT game.*, genre.genre_name
FROM game, genre
WHERE genre.genre_name LIKE "Fi%" AND genre.id = game.genre_id


//cercare una lettera in una stringa (che sia ovunque, non solo che inizi con esso)
SELECT game.*, genre.genre_name
FROM game, genre
WHERE genre.genre_name LIKE "%S%" AND genre.id = game.genre_id

//per contare le righe di un qualcosa cercato
SELECT COUNT(*), game.*, genre.genre_name
FROM game, genre
WHERE genre.genre_name LIKE "%Sport%" AND genre.id = game.genre_id

//Per unire due tabelle con le stesse colone una sotto l'altra (e li mette già in ordine e distinti)
SELECT *
FROM sedeA
UNION 
SELECT * 
FROM sedeB

OPPURE per togliere le ripetizioni del tutto

SELECT *
FROM sedeA
UNION ALL 
SELECT * 
FROM sedeB
ORDER BY codOperaio --in teoria lo fa in automatico, ma non si sa mai

//crea una colonna di calcolo (utile per l'Iva per es) in più, NON LA SALVA, solo nella visualizzazione si vede
SELECT *, "sede A" as sede
FROM sedeA
UNION ALL 
SELECT *, "sede B" as sede
FROM sedeB
ORDER BY codOperaio

SELECT superhero.id, superhero_name, power_name, power_id
FROM superhero, superpower, hero_power
WHERE superhero.id = 70;

//per fare una regex
anno CHAR(4)
CHECK (anno REGEXP '^[0-9]{4}$')

//creare una vista, la aggiorna in automatico
CREATE VIEW "VistaProva" AS

//crea una tabella, NON la aggiorna
CREATE TABLE "tabMigliori" AS
SELECT
FROM
WHERE

//regex regole inizio e fine
^ all'inizio
$ alla fine

//per mettere le maiuscole nel cognome e nel nome
"classe" REGEXP '^[1-5][A-Z]$'
"nome" REGEXP '^[A-Z][a-z]+$'
"cognome" REGEXP '^[A-Z][a-z]+$'

"media_voti" BETWEEN 0 AND 10